"""dundie utils unit test."""

import pytest
from pwdlib.exceptions import UnknownHashError

from dundie.utils.email import check_valid_email
from dundie.utils.user import (
    generate_password_hash,
    generate_simple_password,
    verify_password,
)
from tests.constants import INVALID_EMAILS, VALID_EMAILS


@pytest.mark.unit
@pytest.mark.parametrize("valid_email", VALID_EMAILS)
def test_positive_check_valid_email(valid_email: str) -> None:
    """
    Test that the check_valid_email function correctly identifies a valid\
    email address.

    Asserts:
        The check_valid_email function returns True for a valid email address.
    """
    assert check_valid_email(valid_email) is True


@pytest.mark.unit
@pytest.mark.parametrize("invalid_email", INVALID_EMAILS)
def test_negative_check_valid_email(invalid_email: str) -> None:
    """
    Test that the check_valid_email function correctly identifies an invalid\
    email address.

    Asserts:
      The check_valid_email function returns False for an invalid email
        address.
    """
    assert check_valid_email(invalid_email) is False


@pytest.mark.unit
def test_generate_password_hash_valid_input() -> None:
    """
    Test that generate_password_hash correctly hashes a valid password.

    Asserts:
        The hashed password is a non-empty string and does not match the
        plain text password.
    """
    plain_password = "securepassword123"
    hashed_password = generate_password_hash(plain_password)

    assert isinstance(hashed_password, str)
    assert hashed_password != plain_password
    assert len(hashed_password) > 0


@pytest.mark.unit
def test_generate_password_hash_consistency() -> None:
    """
    Test that generate_password_hash produces different hashes for the same\
    password (if the hashing algorithm uses salting).

    Asserts:
        The hashed passwords for the same input are different.
    """
    plain_password = "securepassword123"
    hashed_password_1 = generate_password_hash(plain_password)
    hashed_password_2 = generate_password_hash(plain_password)

    assert hashed_password_1 != hashed_password_2


@pytest.mark.unit
def test_generate_password_hash_and_verify() -> None:
    """
    Test that a hashed password generated by generate_password_hash can be\
    verified using verify_password.

    Asserts:
        The verify_password function returns True for the correct plain
        password and False for an incorrect one.
    """
    plain_password = "securepassword123"
    hashed_password = generate_password_hash(plain_password)

    assert verify_password(plain_password, hashed_password) is True
    assert verify_password("wrongpassword", hashed_password) is False


@pytest.mark.unit
def test_verify_password_correct_match() -> None:
    """
    Test that verify_password returns True for a correct password match.

    Asserts:
        The function returns True when the plain password matches the hashed password.
    """
    plain_password = "securepassword123"
    hashed_password = generate_password_hash(plain_password)

    assert verify_password(plain_password, hashed_password) is True


@pytest.mark.unit
def test_verify_password_incorrect_match() -> None:
    """
    Test that verify_password returns False for an incorrect password match.

    Asserts:
        The function returns False when the plain password does not match the
          hashed password.
    """
    plain_password = "securepassword123"
    hashed_password = generate_password_hash(plain_password)

    assert verify_password("wrongpassword", hashed_password) is False


@pytest.mark.unit
def test_verify_password_empty_plain_password() -> None:
    """
    Test that verify_password handles an empty plain password.

    Asserts:
        The function returns False when the plain password is empty.
    """
    hashed_password = generate_password_hash("securepassword123")

    assert verify_password("", hashed_password) is False


@pytest.mark.unit
def test_verify_password_empty_hashed_password() -> None:
    """
    Test that verify_password handles an empty hashed password.

    Asserts:
        The function returns False when the hashed password is empty.
    """
    plain_password = "securepassword123"

    assert verify_password(plain_password, "") is False


@pytest.mark.unit
def test_verify_password_invalid_hash_format() -> None:
    """
    Test that verify_password handles an invalid hash format.

    Asserts:
        The function returns False when the hashed password has an invalid format.
    """
    plain_password = "securepassword123"
    invalid_hashed_password = "invalidhash"

    assert verify_password(plain_password, invalid_hashed_password) is False


@pytest.mark.unit
def test_verify_password_invalid_hash(monkeypatch: pytest.MonkeyPatch) -> None:
    """Test `verify_password` with an invalid hash."""

    def mock_verify(*args: tuple, **kwargs: dict) -> None:
        raise UnknownHashError("invalid_hash")

    monkeypatch.setattr(
        "dundie.utils.user.password_hash_instance.verify", mock_verify
    )
    assert verify_password("password", "invalid_hash") is False


@pytest.mark.unit
def test_generate_simple_password_default_size() -> None:
    """Test `generate_simple_password` with default size."""
    password = generate_simple_password()
    assert len(password) == 8
    assert password.isalnum()


@pytest.mark.unit
def test_generate_simple_password_custom_size() -> None:
    """Test `generate_simple_password` with custom size."""
    size = 12
    password = generate_simple_password(size=size)
    assert len(password) == size
    assert password.isalnum()


@pytest.mark.unit
def test_generate_simple_password_edge_case_size() -> None:
    """Test `generate_simple_password` with edge case sizes."""
    small_password = generate_simple_password(size=1)
    assert len(small_password) == 1
    assert small_password.isalnum()

    large_password = generate_simple_password(size=62)
    assert len(large_password) == 62
    assert large_password.isalnum()


@pytest.mark.unit
def test_generate_simple_password_invalid_size() -> None:
    """Test `generate_simple_password` with invalid sizes."""
    # Size less than 1 should default to 8
    password = generate_simple_password(size=0)
    assert len(password) == 8
    assert password.isalnum()

    # Size greater than 62 should default to 62
    password = generate_simple_password(size=100)
    assert len(password) == 62
    assert password.isalnum()


@pytest.mark.unit
def test_positive_generate_simple_password() -> None:
    """
    Test that the generate_simple_password function generates a password of\
    the correct length.

    Asserts:
        The generated password is of the correct length.
    """
    # TODO: Generate hashed complex password with encryption
    # Conversion to set removes duplicates
    passwords = {generate_simple_password(size=8) for _ in range(100)}

    assert len(passwords) == 100  # Check that all passwords are unique
